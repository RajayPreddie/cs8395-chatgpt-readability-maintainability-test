{
    "id": "problem_8",
    "description": "Act as a Python developer and write a Python program that strictly adheres to the pydocstyle standard for docstrings. Here's an example snippet:\n\n\"\"\"Module for demonstrating pydocstyle adherence.\n\nThis module provides examples of how to write docstrings that conform to pydocstyle standards.\n\"\"\"\n\ndef add_numbers(x, y):\n    \"\"\"Add two numbers and return the result.\n\n    :param x: The first number to add.\n    :param y: The second number to add.\n    :return: The sum of x and y.\n    \"\"\"\n    return x + y\n\nFocus on comprehensive and compliant docstring documentation. Return only the raw code for the Python program, ensuring it's functional and follows Python best practices. Verify the program's correctness as if using a Command Line Interface. Use the following keyword(s) to solve a problem with Python: ContextManager.Remember to only respond with the raw code for the Python program. Generate a Python program that uses the keyword(s) for inspiration on the type of problem to solve. Only return the code that you would write in a .py file. Do not output in Markdown format.\n\n",
    "code": "\nimport contextlib\n\nclass ContextManager:\n    \"\"\"Provide a template for a context manager class.\n\n    This class is a basic context manager that can be used to manage resources.\n    It demonstrates the use of the __enter__ and __exit__ magic methods.\n    \"\"\"\n\n    def __enter__(self):\n        \"\"\"Enter the runtime context related to this object.\n\n        The 'with' statement will bind this method's return value to the target\n        specified in the as clause of the statement, if any.\n\n        :return: self or another resource that needs to be managed\n        \"\"\"\n        print(\"Entering context.\")\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"Exit the runtime context and perform any cleanup actions.\n\n        The parameters describe the exception that caused the context to be exited.\n        If the context was exited without an exception, all three arguments will be None.\n\n        :param exc_type: The exception type if an exception has occurred, otherwise None.\n        :param exc_value: The exception value if an exception has occurred, otherwise None.\n        :param traceback: The traceback if an exception has occurred, otherwise None.\n        :return: False to propagate the exception, True to suppress it.\n        \"\"\"\n        print(\"Exiting context.\")\n        if exc_type:\n            print(f\"An exception occurred: {exc_value}\")\n            return False  # Propagate the exception\n        return True  # Suppress the exception\n\ndef use_context_manager():\n    \"\"\"Demonstrate the usage of the ContextManager class.\n\n    This function uses the ContextManager to manage resources within a block of code.\n    It showcases how to work with context managers and ensures that resources are\n    properly cleaned up after usage.\n\n    :return: None\n    \"\"\"\n    with ContextManager() as manager:\n        print(\"Inside the context.\")\n\nif __name__ == \"__main__\":\n    use_context_manager()\n",
    "tags": [
        "ContextManager",
        "Easy"
    ],
    "keywords": [
        "ContextManager"
    ],
    "difficulty": "Easy",
    "prompt_style_adherence": "pydocstyle"
}
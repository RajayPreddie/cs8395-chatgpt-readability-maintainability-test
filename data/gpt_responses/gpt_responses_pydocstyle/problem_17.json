{
    "id": "problem_17",
    "description": "Act as a Python developer and write a Python program that strictly adheres to the pydocstyle standard for docstrings. Here's an example snippet:\n\n\"\"\"Module for demonstrating pydocstyle adherence.\n\nThis module provides examples of how to write docstrings that conform to pydocstyle standards.\n\"\"\"\n\ndef add_numbers(x, y):\n    \"\"\"Add two numbers and return the result.\n\n    :param x: The first number to add.\n    :param y: The second number to add.\n    :return: The sum of x and y.\n    \"\"\"\n    return x + y\n\nFocus on comprehensive and compliant docstring documentation. Return only the raw code for the Python program, ensuring it's functional and follows Python best practices. Verify the program's correctness as if using a Command Line Interface. Use the following keyword(s) to solve a problem with Python: GarbageCollection,Generator,Global state.Remember to only respond with the raw code for the Python program. Generate a Python program that uses the keyword(s) for inspiration on the type of problem to solve. Only return the code that you would write in a .py file. Do not output in Markdown format.\n\n",
    "code": "\nclass GarbageCollectionHelper:\n    \"\"\"Provide a context manager to force garbage collection.\n\n    This class is a context manager that can be used to ensure that garbage\n    collection occurs within a specific block of code.\n\n    Example:\n        with GarbageCollectionHelper():\n            # perform tasks that create garbage\n            pass\n\n    \"\"\"\n\n    def __enter__(self):\n        \"\"\"Enter the runtime context related to this object.\n\n        The with statement will bind this method's return value to the target\n        specified in the as clause of the statement, if any.\n\n        \"\"\"\n        import gc\n        gc.disable()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"Exit the runtime context and enable garbage collection.\n\n        Args:\n            exc_type: The exception type if raised.\n            exc_value: The exception value if raised.\n            traceback: The traceback object if an exception was raised.\n\n        \"\"\"\n        import gc\n        gc.enable()\n        gc.collect()\n\n\ndef infinite_sequence():\n    \"\"\"Generate an infinite sequence of numbers starting from 0.\n\n    Yields:\n        int: The next number in the sequence.\n\n    \"\"\"\n    num = 0\n    while True:\n        yield num\n        num += 1\n\n\n_global_state = {}\ndef update_global_state(key, value):\n    \"\"\"Update the global state dictionary with a new key-value pair.\n\n    Args:\n        key: The key under which to store the value.\n        value: The value to store under the key.\n\n    \"\"\"\n    _global_state[key] = value\n\n\ndef get_global_state(key):\n    \"\"\"Retrieve a value from the global state dictionary.\n\n    Args:\n        key: The key for which to retrieve the value.\n\n    Returns:\n        The value stored under the key, or None if the key does not exist.\n\n    \"\"\"\n    return _global_state.get(key)\n\n\nif __name__ == \"__main__\":\n    # Example usage of GarbageCollectionHelper\n    with GarbageCollectionHelper():\n        # Code that may create unnecessary garbage\n        pass\n\n    # Example usage of infinite_sequence generator\n    gen = infinite_sequence()\n    for _ in range(10):\n        print(next(gen))\n\n    # Example usage of global state functions\n    update_global_state('my_key', 'my_value')\n    print(get_global_state('my_key'))\n",
    "tags": [
        "GarbageCollection",
        "Generator",
        "Global state",
        "Hard"
    ],
    "keywords": [
        "GarbageCollection",
        "Generator",
        "Global state"
    ],
    "difficulty": "Hard",
    "prompt_style_adherence": "pydocstyle"
}
{
    "id": "problem_17",
    "description": "Act as a Python developer and write a Python program that strictly adheres to the pydocstyle standard for docstrings. Here's an example snippet:\n\n\"\"\"Module for demonstrating pydocstyle adherence.\n\nThis module provides examples of how to write docstrings that conform to pydocstyle standards.\n\"\"\"\n\ndef add_numbers(x, y):\n    \"\"\"Add two numbers and return the result.\n\n    :param x: The first number to add.\n    :param y: The second number to add.\n    :return: The sum of x and y.\n    \"\"\"\n    return x + y\n\nFocus on comprehensive and compliant docstring documentation. Return only the raw code for the Python program, ensuring it's functional and follows Python best practices. Verify the program's correctness as if using a Command Line Interface. Use the following keyword(s) to solve a problem with Python: GarbageCollection,Generator,Global state.Remember to only respond with the raw code for the Python program. Generate a Python program that uses the keyword(s) for inspiration on the type of problem to solve. Only return the code that you would write in a .py file. Do not output in Markdown format.\n\n",
    "code": "\nimport gc\n\n\ndef garbage_collection_status():\n    \"\"\"Check the status of the garbage collection.\n\n    This function reports whether the garbage collector is enabled and provides\n    the count of objects it is currently tracking.\n\n    :return: A tuple with a boolean indicating if garbage collection is enabled\n             and an integer with the current object count.\n    \"\"\"\n    gc_enabled = gc.isenabled()\n    object_count = len(gc.get_objects())\n    return gc_enabled, object_count\n\n\ndef generate_integers(n):\n    \"\"\"Generate a sequence of integers from 0 to n-1.\n\n    This generator yields a sequence of integers, which can be useful for\n    iterating over a range without creating an entire list in memory.\n\n    :param n: The upper limit of the range to generate integers for.\n    :yield: The next integer in the range from 0 to n-1.\n    \"\"\"\n    for i in range(n):\n        yield i\n\n\nGLOBAL_STATE = {}\n\n\ndef update_global_state(key, value):\n    \"\"\"Update a key-value pair in the global state dictionary.\n\n    This function updates the global state with the provided key-value pair.\n    The global state is maintained as a dictionary.\n\n    :param key: The key under which the value should be stored.\n    :param value: The value to be stored in the global state.\n    \"\"\"\n    GLOBAL_STATE[key] = value\n\n\ndef get_global_state(key):\n    \"\"\"Retrieve a value from the global state dictionary.\n\n    This function returns the value associated with the provided key in the\n    global state dictionary. If the key is not found, `None` is returned.\n\n    :param key: The key for which the value should be retrieved.\n    :return: The value associated with the key, or `None` if the key is not found.\n    \"\"\"\n    return GLOBAL_STATE.get(key)\n\n\n# Example usage:\n\n# Check garbage collection status\ngc_status = garbage_collection_status()\nprint(f\"Garbage Collection Enabled: {gc_status[0]}, Object Count: {gc_status[1]}\")\n\n# Generate integers using a generator\nfor number in generate_integers(10):\n    print(number)\n\n# Update and retrieve from global state\nupdate_global_state('user', 'Alice')\nprint(get_global_state('user'))\n",
    "tags": [
        "GarbageCollection",
        "Generator",
        "Global state",
        "Hard"
    ],
    "keywords": [
        "GarbageCollection",
        "Generator",
        "Global state"
    ],
    "difficulty": "Hard",
    "prompt_style_adherence": "pydocstyle"
}